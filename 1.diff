diff --git a/src/app_main.c b/src/app_main.c
index b4c80ad..4ae95e7 100644
--- a/src/app_main.c
+++ b/src/app_main.c
@@ -40,7 +40,6 @@ void app_main() {
     int input_len = 0;
     // Structured APDU command
     command_t cmd;
-
     io_init();
 
     ui_menu_main();
diff --git a/src/handler/sign_tx.c b/src/handler/sign_tx.c
index 221b4d3..3f77f1a 100644
--- a/src/handler/sign_tx.c
+++ b/src/handler/sign_tx.c
@@ -77,6 +77,7 @@ int handler_sign_tx(buffer_t *cdata, uint8_t chunk, bool more) {
                             .offset = 0};
 
             parser_status_e status = transaction_deserialize(&buf, &G_context.tx_info.transaction);
+            PRINTF("xiexiestatus %d\n", status);
             return (status != PARSING_OK && !N_storage.blind_signed_allowed)
                        ? io_send_sw(SW_TX_PARSING_FAIL)
                        : handler_hash_tx_and_display_tx(status);
diff --git a/src/sw.h b/src/sw.h
index 6736534..a6be833 100644
--- a/src/sw.h
+++ b/src/sw.h
@@ -67,4 +67,6 @@
 /**
  * Status word for wrong personal msg length.
  */
-#define SW_WRONG_PERSONAL_MSG_LENGTH 0xB00A
\ No newline at end of file
+#define SW_WRONG_PERSONAL_MSG_LENGTH 0xB00A
+
+#define SW_INVALID_TRANSACTION  0xB00B
\ No newline at end of file
diff --git a/src/transaction/deserialize.c b/src/transaction/deserialize.c
index 285e270..553ec24 100644
--- a/src/transaction/deserialize.c
+++ b/src/transaction/deserialize.c
@@ -117,27 +117,27 @@ parser_status_e transaction_deserialize(buffer_t *buf, transaction_t *tx) {
     if (status != PARSING_OK) {
         return status;
     }
-
+    PRINTF("deserialize header\n");
     status = transaction_deserialize_payload_size(buf, tx);
     if (status != PARSING_OK) {
         return status;
     }
-
+    PRINTF("deserialize payload size\n");   
     status = transaction_deserialize_contract(buf, tx);
     if (status != PARSING_OK) {
         return status;
     }
-
+    PRINTF("deserialize contract\n");
     status = transaction_deserialize_method(buf, tx);
     if (status != PARSING_OK) {
         return status;
     }
-
+    PRINTF("deserialize method\n");
     status = transaction_deserialize_params(buf, tx);
     if (status != PARSING_OK) {
         return status;
     }
-
+    PRINTF("deserialize params\n");
     size_t len = 0;
     switch (tx->contract.type) {
         case NATIVE_CONTRACT:
@@ -378,26 +378,35 @@ parser_status_e transaction_deserialize_params(buffer_t *buf, transaction_t *tx)
     LEDGER_ASSERT(tx != NULL, "NULL tx");
     // If the method is transfer or transferV2 for ONG or ONT, call
     // native_transfer_deserialize_params
+    PRINTF("transaction_deserialize_param111111111\n");
+    PRINTF("After: data points to\n");
     if (tx->contract.type == NATIVE_CONTRACT) {
+        PRINTF("transaction_deserialize_params 1");
         bool is_ont = memcmp(tx->contract.addr.data, ONT_ADDR, ADDRESS_LEN) == 0;
         bool is_ong = memcmp(tx->contract.addr.data, ONG_ADDR, ADDRESS_LEN) == 0;
         if (is_ont || is_ong) {
             bool is_transfer =
                 (tx->method.name.len == strlen(METHOD_TRANSFER) &&
                  memcmp(tx->method.name.data, METHOD_TRANSFER, tx->method.name.len) == 0);
+                 PRINTF("111111\n");
             bool is_transfer_v2 =
                 (tx->method.name.len == strlen(METHOD_TRANSFER_V2) &&
                  memcmp(tx->method.name.data, METHOD_TRANSFER_V2, tx->method.name.len) == 0);
+                 PRINTF("222222\n");
             bool is_transfer_from_v2 =
                 (tx->method.name.len == strlen(METHOD_TRANSFER_FROM_V2) &&
                  memcmp(tx->method.name.data, METHOD_TRANSFER_FROM_V2, tx->method.name.len) == 0);
             bool is_approve_v2 =
                 (tx->method.name.len == strlen(METHOD_APPROVE_V2) &&
                  memcmp(tx->method.name.data, METHOD_APPROVE_V2, tx->method.name.len) == 0);
-            tx->contract.token_decimals = is_ont ? 0 : 9;
+                PRINTF("66666666666666666\n");
+           tx->contract.token_decimals = is_ont ? 0 : 9;
+            PRINTF("test 22222222222222\n");
             if (is_transfer_v2 || is_transfer_from_v2 || is_approve_v2) {
+                PRINTF("test 111111111111\n");
                 tx->contract.token_decimals += 9;
             }
+            PRINTF("transaction_deserialize_params\n");
             if (is_transfer || is_transfer_v2) {
                 return native_transfer_deserialize_params(buf, tx);
             }
diff --git a/src/ui/display.h b/src/ui/display.h
index 9b0dd6f..cf90377 100644
--- a/src/ui/display.h
+++ b/src/ui/display.h
@@ -1,6 +1,8 @@
 #pragma once
 
 #include <stdbool.h>  // bool
+#include "../transaction/tx_types.h"
+#include "nbgl_use_case.h"
 
 #if defined(TARGET_NANOX) || defined(TARGET_NANOS2)
 #define ICON_APP_BOILERPLATE C_nanos_app_ont14px
@@ -10,6 +12,17 @@
 #define ICON_APP_WARNING     C_Warning_64px
 #endif
 
+typedef struct {
+    const char *method_name;           
+    const char *title;                 
+    const char *content;              
+    void (*param_handler)(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs);
+} method_display_t;
+
+// 通用参数解析函数
+void parse_param_to_pair(transaction_t *tx, nbgl_contentTagValue_t *pair, const char *tag, 
+                         tx_parameter_type_e type, uint8_t param_idx, char *buffer, size_t buffer_len);
+
 /**
  * Callback to reuse action with approve/reject in step FLOW.
  */
diff --git a/src/ui/nbgl_display_transaction.c b/src/ui/nbgl_display_transaction.c
index 4082184..369d9b3 100755
--- a/src/ui/nbgl_display_transaction.c
+++ b/src/ui/nbgl_display_transaction.c
@@ -39,6 +39,291 @@
 #include "types.h"
 #include "../transaction/contract.h"
 #include "../transaction/utils.h"
+
+
+#define MAX_BUFFER_LEN 68  
+#define NUM_BUFFERS    11  
+
+typedef enum {
+    BUFFER_AMOUNT = 0,
+    BUFFER_ADDRESS,
+    BUFFER_FROM,
+    BUFFER_TO,
+    BUFFER_PEER_PUBKEY,
+    BUFFER_PEER_PUBKEY_1,
+    BUFFER_PEER_PUBKEY_2,
+    BUFFER_PUBKEY_NUMBER,
+    BUFFER_TITLE,
+    BUFFER_TITLE_TWO,
+    BUFFER_TITLE_THREE
+} buffer_index_e;
+
+static char g_buffers[NUM_BUFFERS][MAX_BUFFER_LEN];
+static nbgl_contentTagValue_t pairs[10];
+static nbgl_contentTagValueList_t pairList;
+
+static void clear_buffers(void) {
+    for (uint8_t i = 0; i < NUM_BUFFERS; i++) {
+        explicit_bzero(g_buffers[i], MAX_BUFFER_LEN);
+    }
+}
+
+// 所有方法的参数处理函数
+static void handle_transfer_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [from_addr, to_addr, amount] (Native/WASMVM) 或 [amount, from_addr, to_addr] (NEOVM)
+    uint8_t from_idx = (tx->contract.type == NEOVM_CONTRACT) ? 1 : 0;
+    uint8_t to_idx = (tx->contract.type == NEOVM_CONTRACT) ? 2 : 1;
+    uint8_t amount_idx = 2;
+
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], AMOUNT, PARAM_AMOUNT, amount_idx, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], FROM, PARAM_ADDR, from_idx, g_buffers[BUFFER_FROM], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], TO, PARAM_ADDR, to_idx, g_buffers[BUFFER_TO], MAX_BUFFER_LEN);
+}
+
+static void handle_transfer_from_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [sender_addr, from_addr, to_addr, amount] (Native/WASM) 或 [amount, sender_addr, from_addr, to_addr] (NEOVM)
+    uint8_t sender_idx = (tx->contract.type == NEOVM_CONTRACT) ? 1 : 0;
+    uint8_t from_idx = (tx->contract.type == NEOVM_CONTRACT) ? 2 : 1;
+    uint8_t to_idx = (tx->contract.type == NEOVM_CONTRACT) ? 3 : 2;
+    uint8_t amount_idx = (tx->contract.type == NEOVM_CONTRACT) ? 0 : 2;
+
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], AMOUNT, PARAM_AMOUNT, amount_idx, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], SENDER, PARAM_ADDR, sender_idx, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], FROM, PARAM_ADDR, from_idx, g_buffers[BUFFER_FROM], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], TO, PARAM_ADDR, to_idx, g_buffers[BUFFER_TO], MAX_BUFFER_LEN);
+}
+
+static void handle_approve_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [from_addr, to_addr, amount] (Native/WASMVM) 或 [amount, from_addr, to_addr] (NEOVM)
+    uint8_t from_idx = (tx->contract.type == NEOVM_CONTRACT) ? 1 : 0;
+    uint8_t to_idx = (tx->contract.type == NEOVM_CONTRACT) ? 2 : 1;
+    uint8_t amount_idx = 2;
+
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], AMOUNT, PARAM_AMOUNT, amount_idx, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], FROM, PARAM_ADDR, from_idx, g_buffers[BUFFER_FROM], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], TO, PARAM_ADDR, to_idx, g_buffers[BUFFER_TO], MAX_BUFFER_LEN);
+}
+
+static void handle_register_candidate_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    pairs[(*nbPairs)].item = STAKE_FEE; pairs[(*nbPairs)++].value = STAKE_FEE_ONG;
+}
+
+static void handle_quit_node_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+}
+
+static void handle_add_init_pos_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address, amount]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], POS, PARAM_AMOUNT, 2, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+}
+
+static void handle_reduce_init_pos_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address, amount]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], AMOUNT, PARAM_AMOUNT, 2, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+}
+
+static void handle_change_max_auth_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address, amount]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], MAX_AUTHORIZE, PARAM_AMOUNT, 2, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+}
+
+static void handle_set_fee_percentage_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [peer_pubkey, address, amount]
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY, PARAM_PUBKEY, 0, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 1, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], PEER_COST, PARAM_AMOUNT, 2, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+}
+
+static void handle_authorize_for_peer_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [address, pubkey_num, pubkey1, pubkey2, ...]
+    uint8_t pubkey_num = getValueByLen(tx->method.parameters[1].data, tx->method.parameters[1].len);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 0, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    
+    if (pubkey_num >= 1) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 1", PARAM_PUBKEY, 2, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 2) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 2", PARAM_PUBKEY, 3, g_buffers[BUFFER_PEER_PUBKEY_1], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 3) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 3", PARAM_PUBKEY, 4, g_buffers[BUFFER_PEER_PUBKEY_2], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num > 1) {
+        format_u64(g_buffers[BUFFER_PUBKEY_NUMBER], MAX_BUFFER_LEN, pubkey_num);
+        pairs[(*nbPairs)].item = NODE_AMOUNT; pairs[(*nbPairs)++].value = g_buffers[BUFFER_PUBKEY_NUMBER];
+    }
+}
+
+static void handle_unauthorize_for_peer_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [address, pubkey_num, pubkey1, pubkey2, ...]
+    uint8_t pubkey_num = getValueByLen(tx->method.parameters[1].data, tx->method.parameters[1].len);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 0, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    
+    if (pubkey_num >= 1) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 1", PARAM_PUBKEY, 2, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 2) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 2", PARAM_PUBKEY, 3, g_buffers[BUFFER_PEER_PUBKEY_1], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 3) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 3", PARAM_PUBKEY, 4, g_buffers[BUFFER_PEER_PUBKEY_2], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num > 1) {
+        format_u64(g_buffers[BUFFER_PUBKEY_NUMBER], MAX_BUFFER_LEN, pubkey_num);
+        pairs[(*nbPairs)].item = NODE_AMOUNT; pairs[(*nbPairs)++].value = g_buffers[BUFFER_PUBKEY_NUMBER];
+    }
+}
+
+static void handle_withdraw_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    // 参数: [address, pubkey_num, pubkey1, pubkey2, ..., amount]
+    uint8_t pubkey_num = getValueByLen(tx->method.parameters[1].data, tx->method.parameters[1].len);
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 0, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+    
+    if (pubkey_num >= 1) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 1", PARAM_PUBKEY, 2, g_buffers[BUFFER_PEER_PUBKEY], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 2) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 2", PARAM_PUBKEY, 3, g_buffers[BUFFER_PEER_PUBKEY_1], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num >= 3) {
+        parse_param_to_pair(tx, &pairs[(*nbPairs)++], NBGL_PEER_PUBKEY " 3", PARAM_PUBKEY, 4, g_buffers[BUFFER_PEER_PUBKEY_2], MAX_BUFFER_LEN);
+    }
+    if (pubkey_num > 1) {
+        format_u64(g_buffers[BUFFER_PUBKEY_NUMBER], MAX_BUFFER_LEN, pubkey_num);
+        pairs[(*nbPairs)].item = NODE_AMOUNT; pairs[(*nbPairs)++].value = g_buffers[BUFFER_PUBKEY_NUMBER];
+    }
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], TOTAL_WITHDRAW, PARAM_AMOUNT, 2, g_buffers[BUFFER_AMOUNT], MAX_BUFFER_LEN);
+}
+
+static void handle_withdraw_fee_params(transaction_t *tx, nbgl_contentTagValue_t *pairs, uint8_t *nbPairs) {
+    parse_param_to_pair(tx, &pairs[(*nbPairs)++], ADDRESS, PARAM_ADDR, 0, g_buffers[BUFFER_ADDRESS], MAX_BUFFER_LEN);
+}
+
+static const method_display_t method_table[] = {
+    {METHOD_TRANSFER, OEP4_TX_TITLE, OEP4_TX_CONTENT, handle_transfer_params},
+    {METHOD_TRANSFER_V2, NATIVE_ONG_OR_ONT_TRANSFER_TITLE, NATIVE_ONG_OR_ONT_TRANSFER_CONTENT, handle_transfer_params},
+    {METHOD_TRANSFER_FROM, TRANSFER_FROM_TITLE, TRANSFER_FROM_CONTENT, handle_transfer_from_params},
+    {METHOD_TRANSFER_FROM_V2, TRANSFER_FROM_TITLE, TRANSFER_FROM_CONTENT, handle_transfer_from_params},
+    {METHOD_APPROVE, SIGN_APPROVE_TX_TITLE, SIGN_APPROVE_TX_CONTENT, handle_approve_params},
+    {METHOD_APPROVE_V2, SIGN_APPROVE_TX_TITLE, SIGN_APPROVE_TX_CONTENT, handle_approve_params},
+    {METHOD_REGISTER_CANDIDATE, REGISTER_CANDIDATE_TITLE, REGISTER_CANDIDATE_CONTENT, handle_register_candidate_params},
+    {METHOD_QUIT_NODE, QUIT_NODE_TITLE, QUIT_NODE_CONTENT, handle_quit_node_params},
+    {METHOD_ADD_INIT_POS, ADD_INIT_POS_TITLE, ADD_INIT_POS_CONTENT, handle_add_init_pos_params},
+    {METHOD_REDUCE_INIT_POS, REDUCE_INIT_POS_TITLE, REDUCE_INIT_POS_CONTENT, handle_reduce_init_pos_params},
+    {METHOD_CHANGE_MAX_AUTH, CHANGE_MAX_AUTHORIZATION_TITLE, CHANGE_MAX_AUTHORIZATION_CONTENT, handle_change_max_auth_params},
+    {METHOD_SET_FEE_PERCENTAGE, SET_FEE_PERCENTAGE_TITLE, SET_FEE_PERCENTAGE_CONTENT, handle_set_fee_percentage_params},
+    {METHOD_AUTHORIZE_FOR_PEER, AUTHORIZE_FOR_PEER_TITLE, AUTHORIZE_FOR_PEER_CONTENT, handle_authorize_for_peer_params},
+    {METHOD_UNAUTHORIZE_FOR_PEER, UN_AUTHORIZE_FOR_PEER_TITLE, UN_AUTHORIZE_FOR_PEER_CONTENT, handle_unauthorize_for_peer_params},
+    {METHOD_WITHDRAW, WITHDRAW_TITLE, WITHDRAW_CONTENT, handle_withdraw_params},
+    {METHOD_WITHDRAW_FEE, WITHDRAW_FEE_TITLE, WITHDRAW_FEE_CONTENT, handle_withdraw_fee_params},
+    {NULL, NULL, NULL, NULL} 
+};
+
+void parse_param_to_pair(transaction_t *tx, nbgl_contentTagValue_t *pair, const char *tag, 
+                         tx_parameter_type_e type, uint8_t param_idx, char *buffer, size_t buffer_len) {
+    pair->item = tag;
+    pair->value = buffer;
+    explicit_bzero(buffer, buffer_len);
+
+    tx_parameter_t *param = &tx->method.parameters[param_idx];
+    switch (type) {
+        case PARAM_ADDR:
+            script_hash_to_address(buffer, buffer_len, param->data);
+            break;
+        case PARAM_AMOUNT:
+            get_token_value(param->len, param->data, tx->contract.token_decimals, buffer, buffer_len);
+            if (memcmp(tx->contract.addr.data, ONT_ADDR, ADDRESS_LEN) == 0) strlcat(buffer, ONT_VIEW, buffer_len);
+            else if (memcmp(tx->contract.addr.data, ONG_ADDR, ADDRESS_LEN) == 0) strlcat(buffer, ONG_VIEW, buffer_len);
+            break;
+        case PARAM_PUBKEY:
+            memcpy(buffer, param->data, param->len);
+            buffer[param->len] = '\0';
+            break;
+        default:
+            break;
+    }
+}
+
+static const method_display_t *get_method_display(const transaction_t *tx) {
+    const char *method_data = tx->method.name.data;
+    size_t method_len = tx->method.name.len;
+    for (const method_display_t *entry = method_table; entry->method_name != NULL; entry++) {
+        if (method_len == strlen(entry->method_name) && memcmp(method_data, entry->method_name, method_len) == 0) {
+            return entry;
+        }
+    }
+    return NULL; 
+}
+
+static void review_choice(bool confirm) {
+    validate_transaction(confirm);
+    nbgl_useCaseReviewStatus(confirm ? STATUS_TYPE_TRANSACTION_SIGNED : STATUS_TYPE_TRANSACTION_REJECTED, ui_menu_main);
+}
+
+static int ui_display_transaction_bs_choice(bool is_blind_signed) {
+    PRINTF("ui_display_transaction_bs_choice\n");
+    if (G_context.req_type != CONFIRM_TRANSACTION || G_context.state != STATE_PARSED) {
+        G_context.state = STATE_NONE;
+        return io_send_sw(SW_BAD_STATE);
+    }
+
+    clear_buffers();
+    explicit_bzero(&pairList, sizeof(pairList));
+    pairList.pairs = pairs;
+
+    if (is_blind_signed) {
+        pairs[0].item = BLIND_SIGN_TX; pairs[0].value = BLIND_SIGNING;
+        pairs[1].item = SIGNER; pairs[1].value = G_context.display_data.signer;
+        pairList.nbPairs = 2;
+        nbgl_useCaseReviewBlindSigning(TYPE_TRANSACTION, &pairList, &ICON_APP_BOILERPLATE, 
+                                       BLIND_SIGNING_TITLE, NULL, BLIND_SIGNING_CONTENT, NULL, review_choice);
+    } else {
+        PRINTF("Display transaction\n");
+        const method_display_t *method = get_method_display(&G_context.tx_info.transaction);
+        if (!method) {
+            PRINTF("No match found for method_data\n");
+            return io_send_sw(SW_INVALID_TRANSACTION);
+        }
+        PRINTF("Method found: %s\n", method->method_name);
+        pairList.nbPairs = 0;
+        method->param_handler(&G_context.tx_info.transaction, pairs, &pairList.nbPairs);
+        
+        const char *fee_tag = (memcmp(method->method_name, METHOD_REGISTER_CANDIDATE, strlen(METHOD_REGISTER_CANDIDATE)) == 0) 
+                              ? GAS_FEE : FEE_ONG;
+        pairs[pairList.nbPairs].item = fee_tag; 
+        pairs[pairList.nbPairs].value = G_context.display_data.gas_fee;
+        pairList.nbPairs++;
+        
+        pairs[pairList.nbPairs].item = SIGNER; 
+        pairs[pairList.nbPairs].value = G_context.display_data.signer;
+        pairList.nbPairs++;
+
+        nbgl_useCaseReview(TYPE_TRANSACTION, &pairList, &ICON_APP_BOILERPLATE, 
+                           method->title, NULL, method->content, review_choice);
+    }
+    return 0;
+}
+
+int ui_display_transaction(void) {
+    return ui_display_transaction_bs_choice(false);
+}
+
+int ui_display_blind_signed_transaction(void) {
+    return ui_display_transaction_bs_choice(true);
+}
+/*
+
 // Buffer where the transaction amount string is written
 static char g_amount[40];
 // Buffer where the transaction address string is written
@@ -246,45 +531,10 @@ static uint8_t setTagValuePairs(void) {
         ADD_PAIR(item, g_amount);
         ADD_PAIR(ADDRESS, g_address);
     }
-    /*
-    if (isCommonTx && G_context.tx_type != QUIT_NODE && G_context.tx_type != WITHDRAW_FEE) {
-        const char* item = NULL;
-        switch (G_context.tx_type) {
-            case CHANGE_MAX_AUTHORIZATION: item = MAX_AUTHORIZE; break;
-            case SET_FEE_PERCENTAGE: item = PEER_COST; break;
-            case WITHDRAW: item = (G_context.tx_info.pubkey_number == 1) ? AMOUNT :
-    TOTAL_WITHDRAW; break; case UN_AUTHORIZE_FOR_PEER: case REDUCE_INIT_POS: item = AMOUNT; break;
-            default: item = POS; break;
-        }
-        ADD_PAIR(item, G_context.tx_info.amount);
-    }
-    */
-    /*
-    if (G_context.tx_type == SET_FEE_PERCENTAGE) {
-        ADD_PAIR(STAKE_COST, G_context.tx_info.content_two);
-    }
-        */
     if (is_method(method_data, method_len, METHOD_REGISTER_CANDIDATE)) {
         ADD_PAIR(STAKE_FEE, STAKE_FEE_ONG);
     }
-    /*
-    if (G_context.tx_type == REGISTER_CANDIDATE) {
-        ADD_PAIR(STAKE_FEE, STAKE_FEE_ONG);
-    }
-    */
-    // OEP4 and related transactions
-    /*
-    if (G_context.tx_type == OEP4_TRANSACTION ||
-        G_context.tx_type == NEO_VM_OEP4_APPROVE ||
-        G_context.tx_type == WASM_VM_OEP4_APPROVE ||
-        G_context.tx_type == NEO_VM_OEP4_TRANSFER_FROM ||
-        G_context.tx_type == WASM_VM_OEP4_TRANSFER_FROM) {
-        if (G_context.tx_info.decimals == 0) {
-            ADD_PAIR(DECIMALS, DECIMALS_UNKNOWN);
-        }
-    }
-    */
-    // Transfer and Approve transactions
+       // Transfer and Approve transactions
     bool is_transfer_or_approve =
         is_method(method_data, method_len, METHOD_TRANSFER) ||
         is_method(method_data, method_len, METHOD_TRANSFER_FROM) ||
@@ -387,6 +637,7 @@ static uint8_t setTagValuePairs(void) {
 // - Display the first screen of the transaction review
 // - Display a warning if the transaction is blind-signed
 int ui_display_transaction_bs_choice(bool is_blind_signed) {
+    PRINTF("ui_display_transaction_bs_choice\n");
     if (G_context.req_type != CONFIRM_TRANSACTION || G_context.state != STATE_PARSED) {
         G_context.state = STATE_NONE;
         return io_send_sw(SW_BAD_STATE);
@@ -412,6 +663,7 @@ int ui_display_transaction_bs_choice(bool is_blind_signed) {
                                        NULL,
                                        review_choice);
     } else {
+        PRINTF("Display transaction\n");
         set_display_title_content();
         explicit_bzero(&pairList, sizeof(pairList));
         pairList.nbPairs = setTagValuePairs();
@@ -437,5 +689,6 @@ int ui_display_blind_signed_transaction(void) {
 int ui_display_transaction() {
     return ui_display_transaction_bs_choice(false);
 }
+*/
 
 #endif
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00000.png b/tests/snapshots/stax/test_sign_tx_refused/00000.png
index c813536..4be102d 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00000.png and b/tests/snapshots/stax/test_sign_tx_refused/00000.png differ
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00001.png b/tests/snapshots/stax/test_sign_tx_refused/00001.png
index 039e9f7..8afe2df 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00001.png and b/tests/snapshots/stax/test_sign_tx_refused/00001.png differ
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00002.png b/tests/snapshots/stax/test_sign_tx_refused/00002.png
index bc8862f..5a8d2d7 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00002.png and b/tests/snapshots/stax/test_sign_tx_refused/00002.png differ
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00003.png b/tests/snapshots/stax/test_sign_tx_refused/00003.png
index abc9677..614cb6b 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00003.png and b/tests/snapshots/stax/test_sign_tx_refused/00003.png differ
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00004.png b/tests/snapshots/stax/test_sign_tx_refused/00004.png
index 2b66970..abc9677 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00004.png and b/tests/snapshots/stax/test_sign_tx_refused/00004.png differ
diff --git a/tests/snapshots/stax/test_sign_tx_refused/00005.png b/tests/snapshots/stax/test_sign_tx_refused/00005.png
index 751fa6c..2b66970 100644
Binary files a/tests/snapshots/stax/test_sign_tx_refused/00005.png and b/tests/snapshots/stax/test_sign_tx_refused/00005.png differ
diff --git a/tests/test_sign_cmd.py b/tests/test_sign_cmd.py
index c804677..ee2a8c4 100644
--- a/tests/test_sign_cmd.py
+++ b/tests/test_sign_cmd.py
@@ -58,7 +58,7 @@ def test_sign_tx_short_tx(backend, scenario_navigator):
     logger.debug("pubkey:%s,der_sig:%s,transaction:%s,first_hash:%s",public_key.hex(),der_sig.hex(),transaction.hex(),first_hash.hex())
     assert check_signature_validity(public_key, der_sig, second_hash)
 
-""""
+
 # Transaction signature refused test
 # The test will ask for a transaction signature that will be refused on screen
 def test_sign_tx_refused(backend, scenario_navigator):
@@ -80,4 +80,3 @@ def test_sign_tx_refused(backend, scenario_navigator):
     # Assert that we have received a refusal
     assert e.value.status == Errors.SW_DENY
     assert len(e.value.data) == 0
-"""
\ No newline at end of file
